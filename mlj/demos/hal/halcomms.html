<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Using HAL</title>
  </head>

  <body bgcolor="#ffffff">
<center>
<h1>Using Hal</h1>
</center>
<HR>
The best thing to do is to read the book, but here are some brief
      examples which should be enough to let people who already know
      something about logic and theorem proving to play with the
      applet.

<h3>A simple propositional proof</h3>
Hal implements a theorem prover for first order classical logic. You
	start by saying what it is that you want to prove. For example,
	to prove one direction of the commutativity of conjunction you
	would type
<pre>
goal "P & Q --> Q & P"
</pre>
Hal responds by reminding you of the top-level goal and showing what
	subgoals you currently have:
<pre>
P & Q --> Q & P
 1. empty |- P & Q --> Q & P
</pre>

You can then do the proof interactively from the bottom up, by
repeatedly applying a particular sequent calculus rule to a particular
subgoal. In this case, we might proceed as follows:

<pre>
by (impR 1)
P & Q --> Q & P
 1. P & Q |- Q & P
</pre>
Here we've applied the implication right rule to subgoal 1, yielding
      the new subgoal of proving <tt>Q & P</tt> under the assumption
      <tt>P & Q</tt>. Next we apply the conjunction left rule to that
      subgoal which leaves us having to prove <tt>Q & P</tt> under the
      two
      assumptions <tt>P</tt> and <tt>Q</tt>:
<pre>
by (conjL 1)
P & Q --> Q & P
 1. P, Q |- Q & P
</pre>
Next we apply the conjunction right rule to that subgoal, yielding two
      subgoals:
<pre>
by (conjR 1)
P & Q --> Q & P
 1. P, Q |- Q
 2. P, Q |- R
</pre>
Both of those are instances of the basic axiom, so we just have to
      apply that twice:
<pre>
by (basic 2)
P & Q --> Q & P
 1. P, Q |- Q

by (basic 1)
P & Q --> Q & P
No subgoals left!
</pre>
When there are no subgoals left, we have proved the theorem. 
<h3>A proof with quantifiers</h3>
Hal can also cope with quantifiers. Here's a simple one:
<pre>
goal "(ALL x.P(x)) --> P(a)"
(ALL x. P(x)) --> P(a)
 1. empty |- (ALL x. P(x)) --> P(a)

by (impR 1)
(ALL x. P(x)) --> P(a)
 1. ALL x. P(x) |- P(a)

by (allL 1)
(ALL x. P(x)) --> P(a)
 1. P(?_a), ALL x. P(x) |- P(a)

by (unify 1)
(ALL x. P(x)) --> P(a)
No subgoals left!
</pre>

Note how the left rule for universal quantification introduces a fresh
metavariable <tt>?_a</tt>. The <tt>unify</tt> tactic tries to find a
substitution for the metavariables which will make the subgoal be an
instance of the basic axiom. In this case it succeeds using the
substitution which maps <tt>?_a</tt> to the ordinary variable
<tt>a</tt>.

<h3>A more complicated quantifier proof</h3>
The sequent rules for quantifiers include side conditions which induce
restrictions on which variables can be free in terms substituted for
metavariables. This is demonstrated by the following proof:
<pre>
goal "EX z. P(z) --> (ALL x. P(x))"
EX z. P(z) --> (ALL x. P(x))
 1. empty |- EX z. P(z) --> (ALL x. P(x))

by (exR 1)
EX z. P(z) --> (ALL x. P(x))
 1. empty
    |- P(?_a) --> (ALL x. P(x))
       EX z. P(z) --> (ALL x. P(x))

by (impR 1)
EX z. P(z) --> (ALL x. P(x))
 1. P(?_a)
    |- ALL x. P(x), EX z. P(z) --> (ALL x. P(x)) 

by (allR 1)
EX z. P(z) --> (ALL x. P(x))
 1. P(?_a)
    |- P(_b), EX z. P(z) --> (ALL x. P(x)) 
_b not in ?_a

by (exR 1)
EX z. P(z) --> (ALL x. P(x))
 1. P(?_a)
    |- P(?_c) --> (ALL x. P(x)), P(_b),
       EX z. P(z) --> (ALL x. P(x))
_b not in ?_a

by (impR 1)
EX z. P(z) --> (ALL x. P(x))
 1. P(?_c), P(?_a)
    |- ALL x. P(x), P(b),
       EX z. P(z) --> (ALL x. P(x))
_b not in ?_a

by (unify 1)
EX z. P(z) --> (ALL x. P(x))
No subgoals left!
</pre>

One of the interesting features of this proof is the way in which the
new variable <tt>_b</tt> generated by the application of the universal
quantification right rule is constrained not to be free in any term
which gets substituted for the metavariable <tt>?_a</tt>. This
restriction is shown under the current set of subgoals and prevents
the proof from being finshed off with an application of <tt>unify</tt>
straight after the first application of <tt>allR</tt>.


<h3>Tacticals</h3>
Hal also lets you use tacticals: higher-order functions which let you
generate new tactics from old. These can significantly shorten proofs.
As a silly example, suppose we started off like this:
<pre>
goal "P --> P & (P & (P & P))"
P --> P & (P & (P & P))
 1. empty |- P --> P & (P & (P & P))

by (impR 1)
P --> P & (P & (P & P))
 1. P |- P & (P & (P & P))
</pre>
then it's obvious that we'll have to apply conjunction right and the
basic axiom several times. Instead of doing that by applying the
individual tactics manually, we can use the
tacticals <tt>repeat</tt> and <tt>||</tt> to produce a new tactic that
does the whole thing in one go:
<pre>
by (repeat ((conjR 1) || (basic 1)))
P --> P & (P & (P & P))
No subgoals left!
</pre>

The <tt>||</tt> tactical combines two tactics into the tactic that
tries to do the first and, if that fails, then tries to do the
second. The <tt>repeat</tt> tactical takes a single tactic as argument
and returns the tactic which repeatedly applies that argument
until it fails.
<p>

Hal has some useful tactics built from the elementary logical rules
using tacticals. These can prove quite a few things automatically and
can significantly shorten interactive proofs. The <tt>depth</tt>
tactic, for example, does a depth-first search of the proof tree. This
can get stuck down dead-ends, but works quite often:
<pre>
goal "~ (EX x. ALL Y. J(x,y) <-> ~J(y,y))"
~(EX x. ALL Y. J(x, y) <-> ~J(y, y))
 1. empty 
    |- ~(EX x. ALL Y. J(x, y) <-> ~J(y, y))
by depth
~(EX x. ALL Y. J(x, y) <-> ~J(y, y))
No subgoals left!
</pre>

<h3>Hal applet syntax summary</h3>
The Hal applet implements an interpreter for a little combinatory
language with base types <tt>int</tt>, <tt>string</tt>, <tt>unit</tt>
and <tt>tactic</tt>. The built-in identifiers are
<pre>
goal : string -> unit 
Parses its argument as a formula and makes that the current goal.

by : tactic -> unit
Attempts to apply its argument to the current proof state.

all : tactic
no : tactic
The tactics which always fail and succeed, respectively.

conjL, conjR, disjL, disjR, impL, impR, negL, negR, 
iffL, iffR, exL, exR, allL, allR, basic : int -> tactic
Apply the appropriate sequent calculus rule to the numbered subgoal.

safeSteps : int -> tactic
Applies a sequence of `safe' rules to the numbered subgoal.

quant : int -> tactic
Expands quantifiers in numbered subgoal.

depth : tactic
Solves all subgoals by depth-first search (incompletely).

step : int -> tactic
Tries to use safe steps on numbered subgoal, otherwise using 
unification and quantifier expansion.

depthIt : int -> tactic
Solves all subgoals using depth-first iterative deepening with 
increment given as argument. Compared to depth, this is slower
but doesn't get stuck down blind alleys.

--, ||, |@| : tactic * tactic -> tactic (infix)
Sequential composition, committed and non-commited choice of tactics.

try : tactic -> tactic
Attempts to apply its argument.

repeat : tactic -> tactic
Keeps on trying to apply its argument until it fails.

repeatDeterm : tactic -> tactic
Like repeat, but only considers the first result from each iteration.
</pre>

The syntax of logical formulae should be fairly obvious from the above
      examples. Just to summarise the ASCII representation of the
      connectives:
<pre>
Universal quantification   : ALL x. 
Existential quantification : EX x.
Conjunction                : &
Disjunction                : |
Implication                : -->
Biimplication              : <->
Negation                   : ~
</pre>

<p>
<hr>
<table width="100%">
<tr>
<td align=left><a href="../index.html">MLj home</a></td>
<td align=right>Comments to:
<a href="mailto:mlj@dcs.ed.ac.uk">mlj@dcs.ed.ac.uk</a></td></tr>
</table>

  </body>
</html>
